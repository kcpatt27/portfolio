// scripts/aggregate-projects.ts
// AI-scaffolded: Initial structure generated by Cursor
// Purpose: Aggregates metadata from multiple project documentation files into a single JSON file
// for use in portfolio website generation and project management

import { readFileSync, writeFileSync, mkdirSync } from 'fs'
import { resolve } from 'path'
import yaml from 'js-yaml'

interface ProjectConfig {
  id: string
  name: string
  localPath: string
  specsFile: string
  roadmapFile: string
  architectureFile: string
  [key: string]: any
}

interface ParsedMetadata {
  frontmatter: Record<string, any>
  content: string
}

interface AggregatedProject extends ProjectConfig {
  specs: Record<string, any>
  roadmap: Record<string, any>
  architecture: Record<string, any>
  lastAggregated: string
}

/**
 * Extracts YAML frontmatter from markdown files to parse project metadata.
 * Uses regex instead of a markdown parser to avoid dependencies and handle edge cases
 * where frontmatter might be malformed or missing.
 * 
 * @param content - Raw markdown file content
 * @returns Parsed frontmatter object and remaining content
 */
function parseMarkdownFrontmatter(content: string): ParsedMetadata {
  // Match YAML frontmatter pattern: ---\n...\n---\n followed by content
  // Using [\s\S] instead of . to match newlines in regex
  const match = content.match(/^---\n([\s\S]*?)\n---\n?([\s\S]*)$/)
  
  // Gracefully handle files without frontmatter - return empty metadata but keep content
  // This allows the script to work with both documented and undocumented projects
  if (!match) {
    return {
      frontmatter: {},
      content: content
    }
  }
  
  // Parse YAML frontmatter into JavaScript object for easy access
  const frontmatter = yaml.load(match[1]) as Record<string, any>
  const bodyContent = match[2]
  
  return { frontmatter, content: bodyContent }
}

/**
 * Reads and parses metadata from a project's documentation file.
 * Wraps file operations in try-catch to prevent one missing file from breaking entire aggregation.
 * 
 * @param filePath - Relative or absolute path to the markdown file
 * @returns Parsed frontmatter metadata, or empty object if file doesn't exist
 */
function readProjectMetadata(filePath: string): Record<string, any> {
  try {
    // Resolve to absolute path to handle relative paths correctly
    const fullPath = resolve(filePath)
    const content = readFileSync(fullPath, 'utf8')
    const parsed = parseMarkdownFrontmatter(content)
    // Only return frontmatter - body content not needed for aggregation
    return parsed.frontmatter
  } catch (error) {
    // Warn but continue - allows aggregation to proceed even if some projects
    // are missing documentation files (useful during development)
    console.warn(`Could not read metadata from ${filePath}:`, error)
    return {}
  }
}

/**
 * Main aggregation function that collects metadata from all projects defined in config.
 * Processes each project sequentially to avoid overwhelming the file system and provide
 * clear progress feedback. Creates a unified JSON file for portfolio generation.
 * 
 * Side effects: Creates _aggregated directory and writes portfolio-metadata.json
 */
async function aggregateProjects() {
  // Load project configuration that defines which projects to aggregate
  // Using resolve() ensures path works regardless of where script is run from
  const configPath = resolve('metadata/projects.config.json')
  const config = JSON.parse(readFileSync(configPath, 'utf8'))
  
  const aggregated: AggregatedProject[] = []
  
  // Process each project sequentially for clear logging and error isolation
  for (const project of config.projects) {
    console.log(`Aggregating: ${project.name}...`)
    
    // Read metadata from each project's documentation files
    // Paths are relative to project root, constructed from config
    const specs = readProjectMetadata(
      `${project.localPath}/${project.specsFile}`
    )
    const roadmap = readProjectMetadata(
      `${project.localPath}/${project.roadmapFile}`
    )
    const architecture = readProjectMetadata(
      `${project.localPath}/${project.architectureFile}`
    )
    
    // Combine project config with extracted metadata and timestamp
    // Timestamp helps track when data was last refreshed
    aggregated.push({
      ...project,
      specs,
      roadmap,
      architecture,
      lastAggregated: new Date().toISOString()
    })
  }
  
  // Create output directory if it doesn't exist (recursive: true handles nested paths)
  // This prevents errors when running script for the first time
  mkdirSync('_aggregated', { recursive: true })
  
  // Write aggregated data as formatted JSON for human readability
  // Pretty-printing (null, 2) makes debugging and manual inspection easier
  const outputPath = resolve('_aggregated/portfolio-metadata.json')
  writeFileSync(
    outputPath,
    JSON.stringify(aggregated, null, 2)
  )
  
  console.log(`✓ Aggregated ${aggregated.length} projects`)
  console.log(`✓ Saved to ${outputPath}`)
}

// Run aggregation and handle any errors gracefully
// Using .catch() prevents unhandled promise rejections from crashing the process
aggregateProjects().catch(console.error)